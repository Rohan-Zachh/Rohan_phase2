# BINARY EXPLOITATION 

# 1. Buffer Overflow 0 
Description
Let's start off simple, can you overflow the correct buffer?

## Solution:
1. The challenge has given a source code (a C program). So, I analyzed it first.
2. Like most of the ctfs, this challenge has also given us the hint in the heading, ie BUFFER OVERFLOW.
3. On analyzing the code, I came across these key points.
a) While spotting the buffers in the code, we come across buf2[16], which tells us that the buffer can't take characters more than 16, which resonates with the challenge, ie exceeding it, causes an oevrflow.
b) This overflow usually outputs a segmentation error. But here, the SIGSEGV is modified like;
```
signal(SIGSEGV, sigsegv_handler); // Set up signal handler
```
c) And this modified handler prints the flag as an output for the error.

4. Connecting to the server using netcat : nc saturn.picoctf.net 58719 , I input a string with more than 16 characters and this revealed the flag.
![alt text](file:///d%3A/Cryptonite-Taskphase/TaskPhase-2/Binary%20Exploitation/photo1.1.png)


## Flag:
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```

## Concepts Learned:
1. I learned how a error message of a code can be manipulated the way we want it, by implementing a external handler.

## Notes:
1. Usually in these buffer overflow questions, we need to control the return address. For similar challenges, keep this in mind.

## Resources:
-https://www.geeksforgeeks.org/cpp/buffer-overflow-attack-with-example/ - Used this to understand the concept of buffer overflow.

***

# 2. Format String 0
> Description 
Can you use your knowledge of format strings to make the customers happy? 

## Solution:
1. First of all, I analyse the code given in the challenge. 
2. From the challenge's hint : This is an introduction of format string vulnerabilities. Look up "format specifiers" if you have never seen them before. and the code, I was able to find a lot of format specifiers involved. 
3. Also from the code, I found printf(choice1) and printf(choice2), which are not in their usual syntax form, allowing user to read the memory by passing format specifiers along with the input.
3. Having this knowledge, I connect to the server using netcat : nc mimas.picoctf.net 57117 . 
a) First part : I passed Gr%114d_Cheese, which resembled format specifiers bcz it had % symbol.
```
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
```
b) Second part : I passed Cla%sic_Che%s%steak bcz it had the format specifier %s, which is used for strings and our flag's format is in the string format. This revealed the flag for the challenge.
```
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```

## Flag:
```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```

## Concepts Learned:
- Normally you should write, eg: printf("%s", choice).
- But here, printf(choice1) and printf(choice2) are called without a format string. So, A direct user input as a format string allows you to use %s,etc to read the memory.

## Notes:
1. If you have a prior knowledge about format specifiers, you could just solve the above challenge without even analysing the code and stuff.

## Resources:
- https://cplusplus.com/reference/cstdio/printf/ - To refer the format specifiers 

***

